Error handling in react.js :
React Error Boundaries must be a class under the hood â€” hooks donâ€™t support them natively.
But we can use libraries like react-error-boundary (recommended by the React team) to handle errors in functional components.
npm install react-error-boundary
-------------
controlled react components - value is controlled by react
In React, a controlled component is a form input element (input, textarea, select, etc.) whose value is controlled by React state.

uncontrolled react components  -value is controlled by dom
-------------
how to improve react app performance using lazy loading API?
lazy loading APIs in React means fetching data only when required instead of fetching everything upfront. This is different from just lazy loading components.

It improves performance by:

Reducing initial API calls (faster first render).

Loading data on demand (like pagination, infinite scroll, or conditional requests).

Minimizing network usage.

ðŸ”¹ 1. Load API Data on Demand (Button Click / User Action)

Instead of fetching data when the component mounts, fetch only when the user requests it.
ðŸ”¹ 2. Lazy Load with Intersection Observer (Scroll-based Loading)

Fetch data only when a component comes into view (like infinite scrolling).
------------
lazy loading in react - lazy loading in React is a technique to load components or resources only when needed instead of loading everything upfront.
ðŸ”¹ 1. Lazy Loading Components with React.lazy 
   React provides React.lazy + Suspense for code-splitting.
    <Suspense fallback={<p>Loading...</p>}>
        <LazyComponent />
      </Suspense>
	  Always wrap lazy components in <Suspense>.
ðŸ”¹ 2. Lazy Loading with React Router (Routes)
If youâ€™re using React Router v6+, you can lazy-load route components.
ðŸ”¹ 3. Lazy Loading Images (Performance Optimization)
ðŸ”¹ 4. Conditional Lazy Loading (on-demand)

------------
memoization in React - In React, memoization is all about caching values, so that expensive recalculations or re-renders are avoided

ðŸ”¹ 1. React.memo â€“ Memoizing Components
                   It prevents a functional component from re-rendering unless its props change.
ðŸ”¹ 2. useMemo â€“ Memoizing Values
                   It caches computed values between renders.
                   ðŸ‘‰ Without useMemo, every keystroke would recalculate.
ðŸ”¹ 3. useCallback â€“ Memoizing Functions

It memoizes functions so they arenâ€™t re-created every render.			   
				   
---------
react compose -combining multiple  components into a single one, so that the output of one becomes the input of the next.
---------
Code-splitting in React is a performance optimization technique that helps reduce the initial bundle size by loading parts of the code only when needed. Instead of shipping the entire JavaScript bundle at once, React (with the help of tools like Webpack) can split your code into smaller chunks and load them on demand.
----------
Suspense in React is a built-in component that helps manage the loading state of components that are being rendered asynchronously

--
use state and use ref relation
----
console.log("First");
for(let i = 0; i<5; i++){
   setTimeout(() => {console.log(i)}, 5000)
}
console.log("Last")
----
react fragments 	
